* Coordinate Systems definition


** Coordinate Frame Conventions

All coordinate frames should follow these conventions.
http://www.ros.org/reps/rep-0103.html

*** Chirality

All systems are right handed. This means they comply with the right hand rule [4].

*** Axis Orientation

In relation to a body the standard is:

| x | forward |
| y | left    |
| z | up      |

For short-range Cartesian representations of geographic locations, use the east north up [5] (ENU) convention:

| X | east  |
| Y | north |
| Z | up    |

To avoid precision problems with large float32 values, it is recommended to choose a nearby origin such as your system's starting position.

For outdoor systems where it is desirable to work under the north east down [6] (NED) convention, define an appropriately transformed secondary frame with the "_ned" suffix:

| X | north |
| Y | east  |
| Z | down  |

*** Suffix Frames

In the case of cameras, there is often a second frame defined with a "_optical" suffix. This uses a slightly different convention:

| z | forward |
| x | right   |
| y | down    |

** Coordinate Frames
We define 5 right-handed frames following standard ROS convention (https://www.ros.org/reps/rep-0105.html):


| world         | ${W}$ |
| odometry      | ${O}$ |
| body          | ${B}$ |
| camera        | ${C}$ |
| VI sensor IMU | ${V}$ |

- world ${W}$

  The coordinate frame called map is a world fixed frame, with its Z-axis pointing upwards. The pose of a mobile platform, relative to the map frame, should not significantly drift over time. The map frame is not continuous, meaning the pose of a mobile platform in the map frame can change in discrete jumps at any time.

  In a typical setup, a localization component constantly re-computes the robot pose in the map frame based on sensor observations, therefore eliminating drift, but causing discrete jumps when new sensor information arrives.

  The map frame is useful as a long-term global reference, but discrete jumps in position estimators make it a poor reference frame for local sensing and acting.

- odometry ${O}$

  The coordinate frame ${O}$ is a world-fixed frame.
  The pose of a mobile platform in the odom frame can drift over time, without any bounds. This drift makes the odom frame useless as a long-term global reference.
  However, the pose of a robot in the odom frame is guaranteed to be continuous, meaning that the pose of a mobile platform in the odom frame always evolves in a smooth way, without discrete jumps.

  In a typical setup the odom frame is computed based on an odometry source, such as wheel odometry or an inertial measurement unit.

  The odom frame is useful as an accurate, short-term local reference, but drift makes it a poor frame for long-term reference.

- body ${B}$

- camera ${C}$

- VI sensor IMU ${V}$

** Rotation Representation

#+BEGIN_SRC jupyter-python :session drone-kinematics
import sympy as sp
from galgebra.ga import Ga
from sympy import symbols,sin,cos,sqrt
from galgebra.printer import Eprint

Eprint()

x,y,z = sp.symbols('x y z')
(o3d,ex,ey,ez) = Ga.build('e*x|y|z',g=[1,1,1])
#+END_SRC


#+BEGIN_SRC jupyter-python :session drone-kinematics
print(o3d.mv('S', 'scalar'))
print(o3d.mv('V', 'vector'))
print(o3d.mv('B', 'bivector'))
print(o3d.mv('I', 'pseudo'))

#+END_SRC

#+RESULTS:
: S
: V__x[0m*[0;34me_x[0m + V__y[0m*[0;34me_y[0m + V__z[0m*[0;34me_z[0m
: B__x[0my[0m*[0;34me_x[0m^[0;34me_y[0m + B__x[0mz[0m*[0;34me_x[0m^[0;34me_z[0m + B__y[0mz[0m*[0;34me_y[0m^[0;34me_z[0m
: I__x[0my[0mz[0m*[0;34me_x[0m^[0;34me_y[0m^[0;34me_z[0m


*** Why quaternions?
There are many ways to represent rotations. The preferred order is listed below, along with rationale.

1) quaternion
   - Compact representation
   - No singularities
2) rotation matrix
   - No singularities
3) fixed axis roll, pitch, yaw about X, Y, Z axes respectively
   - No ambiguity on order
   - Used for angular velocities
4) euler angles yaw, pitch, and roll about Z, Y, X axes respectively
   - Euler angles are generally discouraged due to having 24 'valid' conventions with different domains using different conventions by default.

NOTE: By the right hand rule, the yaw component of orientation increases as the child frame rotates counter-clockwise, and for geographic poses, yaw is zero when pointing east.

This requires special mention only because it differs from a traditional compass bearing, which is zero when pointing north and increments clockwise. Hardware drivers should make the appropriate transformations before publishing standard ROS messages.

** Units

Use SI units by default in all code - it's the most consistent international standard. SI units are maintained by Bureau International des Poids et Mesures. and I'd recommend Wikipedia for more info.

#+CAPTION: Base Units
| Quantity | Unit     |
|----------+----------|
| length   | meter    |
| mass     | kilogram |
| time     | second   |
| current  | ampere   |

SI defines seven base units and many derived units. If you are not using SI base units, you should use SI-derived units.

#+CAPTION: Commonly used SI-derived units
| Quantity    | Unit    |
|-------------+---------|
| angle       | radian  |
| frequency   | hertz   |
| force       | newton  |
| power       | watt    |
| voltage     | volt    |
| temperature | celsius |
| magnetism   | tesla   |

* Estimators
Some useful state estimators

- EKF
- Q Attitude estimator
- LPE attitude estimator

** EKF2
EKF2 is an extended kalman filter estimating attitude, 3D position / velocity and wind states.

- Disadvantages
  - The ecl EKF is a complex algorithm that requires a good understanding of extended Kalman filter theory and its application to navigation problems to tune successfully. It is therefore more difficult for users that are not achieving good results to know what to change.
  - The ecl EKF uses more RAM and flash space.
  - The ecl EKF uses more logging space.

- Advantage
  - The ecl EKF is able to fuse data from sensors with different time delays and data rates in a mathematically consistent way which improves accuracy during dynamic maneuvers once time delay parameters are set correctly.
  - The ecl EKF is capable of fusing a large range of different sensor types.
  - The ecl EKF detects and reports statistically significant inconsistencies in sensor data, assisting with diagnosis of sensor errors.
  - For fixed wing operation, the ecl EKF estimates wind speed with or without an airspeed sensor and is able to use the estimated wind in combination with airspeed measurements and sideslip assumptions to extend the dead-reckoning time available if GPS is lost in flight.
  - The ecl EKF estimates 3-axis accelerometer bias which improves accuracy for tailsitters and other vehicles that experience large attitude changes between flight phases.
  - The federated architecture (combined attitude and position/velocity estimation) means that attitude estimation benefits from all sensor measurements. This should provide the potential for improved attitude estimation if tuned correctly.

** LPE position estimator -
  The LPE position estimator is an extended kalman filter for 3D position and velocity states.

** Q attitude estimator -
The attitude Q estimator is a very simple, quaternion based complementary filter for attitude.
* Kalman Filters

The Kalman filter is essentially a set of mathematical equations that implement a two-stage estimator built from a predictor and corrector.

Although the filter is originally developed for use in spacecraft navigation systems, it is now widely used in many other systems including satellite navigation systems, computer vision applications, and object tracking software

A linear system can be described by the following equations

State Space: $x_{k+1} = Ax_k + Bu_k + w_k$
Output Equations: $y_{k} = Cx_k + v_k$

- A, B, and C are constant matrices
- k is time index
- x is state of the equation
- u is control input to the system
- y is measured output
- w is process noise with known covariance
- v is measurement noise

While we know that the $x$ vector contains all the information about the present state of the vector, we can't always observe all of them. What we can see is the $y$ vector - a subset of the states with some gaussian noise.

The Kalman filter algorithm involves two stages: a prediction stage and a measurement update stage. The standard Kalman filter equations for the prediction stage are shown in the following.

Kalman Gain: $K_k = P_kC^T{\( CP_kC^T + R \)}^{-1}$
State Estimation: $x_{k+1} = (Ax_{k} + Bu_{k}) + K_k(y_k - Cx_k)$
Estimation error covariance: $P_{k+1} = A(I-K_{k}C)P_{k}A^{T} + Q$

- P is the estimation error covariance
- R is the measurement noise covariance
- K is the Kalman gain
- Q is the process noise covariance

The state estimation equation consists of two terms:
- Prediction term ($Ax_{k} + Bu_{k}$)
  The first term is the prediction term, which is used to derive the state estimate at time k+1. This value would be the state estimate if the measurement is unavailable.
- Correction term ($K_{k}\(y_{k} - Cx_{k}\)$)
  The second term is the correction term, representing the amount by which to correct the updated state estimate due to the available measurement.


* Kalman Statespace Model
[[file:./images/screenshot-05.png]]


** States

[[file:./images/screenshot-04.png]]

** COMMENT AHRS kinematic model

The Euler angles describe the aircraft body-axis orientation in north, east, and down coordinates.
That means in longitudinal, lateral and normal coordinates, with respect to the local tangent plane to the Earth and true north.
Here \theta is the pitch angle, \phi the roll  angle  and \psi is the yaw angle  according to Figure 2.
The angular velocity vector expressed in body frame is P for  the  roll  rate, Q is  the  pitch  rate  and R is  the  yaw rate; and it is related to the Earth frame by the transformation given by the kinematics equation (1).

SymPy mechanics module

#+BEGIN_SRC jupyter-python :session kinematic_model
import sympy as sp
from sympy.abc import theta, psi, phi
from sympy.physics.mechanics import dynamicsymbols
from sympy.physics.vector import ReferenceFrame, CoordinateSym

# Global Time coordinate
t = sp.Symbol('t')
B = ReferenceFrame('$B$') # Body frame
E = ReferenceFrame('$E$') # Earth frame


# Defined in body frame
roll_rate_b, pitch_rate_b, yaw_rate_b = dynamicsymbols("P Q R", real=True)

# Euler angles defined in earth frame
roll_angle_e = dynamicsymbols("$\phi$", real=True)
pitch_angle_e = dynamicsymbols("$\theta$", real=True)
yaw_angle_e = dynamicsymbols("$\psi$", real=True)
dt_roll_angle_e = roll_angle_e.diff(t)
dt_pitch_angle_e = pitch_angle_e.diff(t)
dt_yaw_angle_e = yaw_angle_e.diff(t)



angular_velocity = sp.Matrix([[roll_rate_b],
                              [pitch_rate_b],
                              [yaw_rate_b]])
dt_euler = sp.Matrix([[dt_roll_rate_e],
                      [dt_pitch_rate_e],
                      [dt_yaw_rate_e]])

kinematics_transformation_matrix = sp.Matrix([[1,
                                               sp.tan(pitch_angle_e)*sp.sin(roll_angle_e),
                                               sp.tan(pitch_angle_e)*sp.sin(roll_angle_e)],
                                              [0, sp.cos(roll_angle_e), -sp.sin(roll_angle_e)],
                                              [0,
                                               sp.sin(roll_angle_e)/sp.cos(pitch_angle_e),
                                               sp.cos(roll_angle_e)/sp.cos(pitch_angle_e)]])

kinematics_transformation_matrix*angular_velocity - dt_euler
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
:
: AttributeErrorTraceback (most recent call last)
: <ipython-input-2-028009470547> in <module>
:      14 yaw_angle_e = dynamicsymbols("$\psi$", real=True)
:      15 dt_roll_angle_e = roll_angle_e.diff(t)
: ---> 16 dt_pitch_angle_e = pitch_angle_e.diff(t)
:      17 dt_yaw_angle_e = yaw_angle_e.diff(t)
:      18
:
: AttributeError: 'list' object has no attribute 'diff'
:END:

* Sensor Calibration

[[file:./images/screenshot-03.png]]

** Accelerometer Calibration
Low pass filter

The accelerometer can determine the pitch and roll of the body by measuring the gravitational acceleration during static or quasi-static conditions

** Magnetometer Calibration
https://www.mathworks.com/help/nav/ug/magnetometer-calibration.html
Ellipse Hypothesis Compensation

** Gyrometer Caliration

https://www.mathworks.com/help/nav/ug/remove-bias-from-angular-velocity-measurement.html

** Camera Calibration

Camera calibration is the process of estimating parameters of the camera using images of a special calibration pattern.
The parameters include camera intrinsics, distortion coefficients, and camera extrinsics.
3-D vision is the process of reconstructing a 3-D scene from two or more views of the scene.

Using the Computer Vision Toolbox™, you can perform dense 3-D reconstruction using a calibrated stereo pair of cameras.
You can also reconstruct the scene using an uncalibrated stereo pair of cameras, up to unknown scale.
Finally, you can compute a sparse 3-D reconstruction from multiple images, using a single-calibrated camera.


*** Single and Stereo Camera Calibration
| detectCheckerboardPoints   | Detect checkerboard pattern in image                           |
| generateCheckerboardPoints | Generate checkerboard corner locations                         |
| undistortImage             | Correct image for lens distortion                              |
| cameraPoseToExtrinsics     | Convert camera pose to extrinsics                              |
| cameraMatrix               | Camera projection matrix                                       |
| cameraParameters           | Object for storing camera parameters                           |
| stereoParameters           | Object for storing stereo camera system parameters             |
| disparityBM                | Compute disparity map using block matching                     |
| disparitySGM               | Compute disparity map through semi-global matching             |
| reconstructScene           | Reconstruct 3-D scene from disparity map                       |
| rectifyStereoImages        | Rectify a pair of stereo images                                |
| triangulate                | 3-D locations of undistorted matching points in stereo images  |
| extrinsics                 | Compute location of calibrated camera                          |
| extrinsicsToCameraPose     | Convert extrinsics to camera pose                              |
| relativeCameraPose         | Compute relative rotation and translation between camera poses |
| stereoAnaglyph             | Create red-cyan anaglyph from stereo pair of images            |
| rotationMatrixToVector     | Convert 3-D rotation matrix to rotation vector                 |
| rotationVectorToMatrix     | Convert 3-D rotation vector to rotation matrix                 |

*** Stereo Vision
| triangulate                       | 3-D locations of undistorted matching points in stereo images |
| undistortImage                    | Correct image for lens distortion                             |
| cameraMatrix                      | Camera projection matrix                                      |
| disparityBM                       | Compute disparity map using block matching                    |
| disparitySGM                      | Compute disparity map through semi-global matching            |
| estimateUncalibratedRectification | Uncalibrated stereo rectification                             |
| lineToBorderPoints                | Intersection points of lines in image and image border        |
| rectifyStereoImages               | Rectify a pair of stereo images                               |
| reconstructScene                  | Reconstruct 3-D scene from disparity map                      |
| stereoParameters                  | Object for storing stereo camera system parameters            |
| stereoAnaglyph                    | Create red-cyan anaglyph from stereo pair of images           |
| rotationMatrixToVector            | Convert 3-D rotation matrix to rotation vector                |
| rotationVectorToMatrix            | Convert 3-D rotation vector to rotation matrix                |

* Deriving state equations
https://dial.uclouvain.be/memoire/ucl/en/object/thesis%3A12954/datastream/PDF_01/view

https://arxiv.org/pdf/1708.06652.pdf



#+BEGIN_SRC jupyter-python :session equation :results raw
from sympy import symbols
from galgebra.ga import Ga

from galgebra.printer import Format
Format(Fmode = False, Dmode = True)

st4coords = (t,x,y,z) = symbols('t x y z', real=True)
st4 = Ga('e',
         g=[1,-1,-1,-1],
         coords=st4coords)

M = st4.mv('M','mv',f = True)

M.grade(3).Fmt(3,r'\langle \mathbf{M} \rangle _3')

#+END_SRC

#+RESULTS:
:RESULTS:
 \begin{align*}   \langle \mathbf{M} \rangle _3 =& M^{txy} {\left (t,x,y,z \right )} \boldsymbol{e}_{t}\wedge \boldsymbol{e}_{x}\wedge \boldsymbol{e}_{y} \\  &  + M^{txz} {\left (t,x,y,z \right )} \boldsymbol{e}_{t}\wedge \boldsymbol{e}_{x}\wedge \boldsymbol{e}_{z} \\  &  + M^{tyz} {\left (t,x,y,z \right )} \boldsymbol{e}_{t}\wedge \boldsymbol{e}_{y}\wedge \boldsymbol{e}_{z} \\  &  + M^{xyz} {\left (t,x,y,z \right )} \boldsymbol{e}_{x}\wedge \boldsymbol{e}_{y}\wedge \boldsymbol{e}_{z}  \end{align*}
:END:

#


** Matlab derivation of navigation EKF

#+BEGIN_SRC octave

% IMPORTANT - This script requires the Matlab symbolic toolbox and takes ~3 hours to run

% Derivation of Navigation EKF using a local NED earth Tangent Frame and
% XYZ body fixed frame
% Sequential fusion of velocity and position measurements
% Fusion of true airspeed
% Sequential fusion of magnetic flux measurements
% 24 state architecture.
% IMU data is assumed to arrive at a constant rate with a time step of dt
% IMU delta angle and velocity data are used as control inputs,
% not observations

% Author:  Paul Riseborough

#+END_SRC


#+BEGIN_SRC octave

% State vector:
% attitude quaternion
% Velocity - m/sec (North, East, Down)
% Position - m (North, East, Down)
% Delta Angle bias - rad (X,Y,Z)
% Delta Velocity bias - m/s (X,Y,Z)
% Earth Magnetic Field Vector - (North, East, Down)
% Body Magnetic Field Vector - (X,Y,Z)
% Wind Vector  - m/sec (North,East)
#+END_SRC

#+BEGIN_SRC octave
% Observations:
% NED velocity - m/s
% NED position - m
% True airspeed - m/s
% angle of sideslip - rad
% XYZ magnetic flux
#+END_SRC

#+BEGIN_SRC octave
% Time varying parameters:
% XYZ delta angle measurements in body axes - rad
% XYZ delta velocity measurements in body axes - m/sec
#+END_SRC

#+BEGIN_SRC octave
%% define symbolic variables and constants
clear all;
reset(symengine);
syms dax day daz real % IMU delta angle measurements in body axes - rad
syms dvx dvy dvz real % IMU delta velocity measurements in body axes - m/sec
syms q0 q1 q2 q3 real % quaternions defining attitude of body axes relative to local NED
syms vn ve vd real % NED velocity - m/sec
syms pn pe pd real % NED position - m
syms dax_b day_b daz_b real % delta angle bias - rad
syms dvx_b dvy_b dvz_b real % delta velocity bias - m/sec
syms dt real % IMU time step - sec
syms gravity real % gravity  - m/sec^2
syms daxVar dayVar dazVar dvxVar dvyVar dvzVar real; % IMU delta angle and delta velocity measurement variances
syms vwn vwe real; % NE wind velocity - m/sec
syms magX magY magZ real; % XYZ body fixed magnetic field measurements - milligauss
syms magN magE magD real; % NED earth fixed magnetic field components - milligauss
syms R_VN R_VE R_VD real % variances for NED velocity measurements - (m/sec)^2
syms R_PN R_PE R_PD real % variances for NED position measurements - m^2
syms R_TAS real  % variance for true airspeed measurement - (m/sec)^2
syms R_MAG real  % variance for magnetic flux measurements - milligauss^2
syms R_BETA real % variance of sidelsip measurements rad^2
syms R_LOS real % variance of LOS angular rate mesurements (rad/sec)^2
syms ptd real % location of terrain in D axis
syms decl real; % earth magnetic field declination from true north
syms R_DECL R_YAW real; % variance of declination or yaw angle observation
syms BCXinv BCYinv real % inverse of ballistic coefficient for wind relative movement along the x and y  body axes
syms rho real % air density (kg/m^3)
syms R_ACC real % variance of accelerometer measurements (m/s^2)^2
syms Kaccx Kaccy real % derivative of X and Y body specific forces wrt component of true airspeed along each axis (1/s)
#+END_SRC

#+BEGIN_SRC octave
%% define the state prediction equations
#+END_SRC

#+BEGIN_SRC octave
% define the measured Delta angle and delta velocity vectors
dAngMeas = [dax; day; daz];
dVelMeas = [dvx; dvy; dvz];
#+END_SRC

#+BEGIN_SRC octave
% define the IMU bias errors and scale factor
dAngBias = [dax_b; day_b; daz_b];
dVelBias = [dvx_b; dvy_b; dvz_b];
#+END_SRC

#+BEGIN_SRC octave
% define the quaternion rotation vector for the state estimate
quat = [q0;q1;q2;q3];
% derive the truth body to nav direction cosine matrix
Tbn = Quat2Tbn(quat);
#+END_SRC

#+BEGIN_SRC octave
% define the truth delta angle
% ignore coning compensation as these effects are negligible in terms of
% covariance growth for our application and grade of sensor
dAngTruth = dAngMeas - dAngBias;
#+END_SRC

#+BEGIN_SRC octave
% Define the truth delta velocity -ignore sculling and transport rate
% corrections as these negligible are in terms of covariance growth for our
% application and grade of sensor
dVelTruth = dVelMeas - dVelBias;
#+END_SRC

#+BEGIN_SRC octave
% define the attitude update equations
% use a first order expansion of rotation to calculate the quaternion increment
% acceptable for propagation of covariances
deltaQuat = [1;
    0.5*dAngTruth(1);
    0.5*dAngTruth(2);
    0.5*dAngTruth(3);
    ];
quatNew = QuatMult(quat,deltaQuat);
#+END_SRC

#+BEGIN_SRC octave
% define the velocity update equations
% ignore coriolis terms for linearisation purposes
vNew = [vn;ve;vd] + [0;0;gravity]*dt + Tbn*dVelTruth;
#+END_SRC

#+BEGIN_SRC octave
% define the position update equations
pNew = [pn;pe;pd] + [vn;ve;vd]*dt;
#+END_SRC

#+BEGIN_SRC octave
% define the IMU error update equations
dAngBiasNew = dAngBias;
dVelBiasNew = dVelBias;
#+END_SRC

#+BEGIN_SRC octave
% define the wind velocity update equations
vwnNew = vwn;
vweNew = vwe;
#+END_SRC

#+BEGIN_SRC octave
% define the earth magnetic field update equations
magNnew = magN;
magEnew = magE;
magDnew = magD;
#+END_SRC

#+BEGIN_SRC octave
% define the body magnetic field update equations
magXnew = magX;
magYnew = magY;
magZnew = magZ;
#+END_SRC

#+BEGIN_SRC octave
% Define the state vector & number of states
stateVector = [quat;vn;ve;vd;pn;pe;pd;dAngBias;dVelBias;magN;magE;magD;magX;magY;magZ;vwn;vwe];
nStates=numel(stateVector);
#+END_SRC

#+BEGIN_SRC octave
% Define vector of process equations
newStateVector = [quatNew;vNew;pNew;dAngBiasNew;dVelBiasNew;magNnew;magEnew;magDnew;magXnew;magYnew;magZnew;vwnNew;vweNew];
#+END_SRC

#+BEGIN_SRC octave
% derive the state transition matrix
F = jacobian(newStateVector, stateVector);
% set the rotation error states to zero
[F,SF]=OptimiseAlgebra(F,'SF');
#+END_SRC

#+BEGIN_SRC octave
% define a symbolic covariance matrix using strings to represent
% '_l_' to represent '( '
% '_c_' to represent ,
% '_r_' to represent ')'
% these can be substituted later to create executable code
for rowIndex = 1:nStates
    for colIndex = 1:nStates
        eval(['syms OP_l_',num2str(rowIndex),'_c_',num2str(colIndex), '_r_ real']);
        eval(['P(',num2str(rowIndex),',',num2str(colIndex), ') = OP_l_',num2str(rowIndex),'_c_',num2str(colIndex),'_r_;']);
    end
end

save 'StatePrediction.mat';

%% derive the covariance prediction equations
% This reduces the number of floating point operations by a factor of 6 or
% more compared to using the standard matrix operations in code

% Error growth in the inertial solution is assumed to be driven by 'noise' in the delta angles and
% velocities, after bias effects have been removed.

% derive the control(disturbance) influence matrix from IMu noise to state
% noise
G = jacobian(newStateVector, [dAngMeas;dVelMeas]);
[G,SG]=OptimiseAlgebra(G,'SG');

% derive the state error matrix
distMatrix = diag([daxVar dayVar dazVar dvxVar dvyVar dvzVar]);
Q = G*distMatrix*transpose(G);
[Q,SQ]=OptimiseAlgebra(Q,'SQ');

% Derive the predicted covariance matrix using the standard equation
PP = F*P*transpose(F) + Q;

% Collect common expressions to optimise processing
[PP,SPP]=OptimiseAlgebra(PP,'SPP');

save('StateAndCovariancePrediction.mat');
clear all;
reset(symengine);

%% derive equations for fusion of true airspeed measurements
load('StatePrediction.mat');
VtasPred = sqrt((vn-vwn)^2 + (ve-vwe)^2 + vd^2); % predicted measurement
H_TAS = jacobian(VtasPred,stateVector); % measurement Jacobian
[H_TAS,SH_TAS]=OptimiseAlgebra(H_TAS,'SH_TAS'); % optimise processing
K_TAS = (P*transpose(H_TAS))/(H_TAS*P*transpose(H_TAS) + R_TAS);
[K_TAS,SK_TAS]=OptimiseAlgebra(K_TAS,'SK_TAS'); % Kalman gain vector

% save equations and reset workspace
save('Airspeed.mat','SH_TAS','H_TAS','SK_TAS','K_TAS');
clear all;
reset(symengine);

%% derive equations for fusion of angle of sideslip measurements
load('StatePrediction.mat');

% calculate wind relative velocities in nav frame and rotate into body frame
Vbw = transpose(Tbn)*[(vn-vwn);(ve-vwe);vd];
% calculate predicted angle of sideslip using small angle assumption
BetaPred = Vbw(2)/Vbw(1);
H_BETA = jacobian(BetaPred,stateVector); % measurement Jacobian
[H_BETA,SH_BETA]=OptimiseAlgebra(H_BETA,'SH_BETA'); % optimise processing
K_BETA = (P*transpose(H_BETA))/(H_BETA*P*transpose(H_BETA) + R_BETA);[K_BETA,SK_BETA]=OptimiseAlgebra(K_BETA,'SK_BETA'); % Kalman gain vector

% save equations and reset workspace
save('Sideslip.mat','SH_BETA','H_BETA','SK_BETA','K_BETA');
clear all;
reset(symengine);

%% derive equations for fusion of magnetic field measurement
load('StatePrediction.mat');

magMeas = transpose(Tbn)*[magN;magE;magD] + [magX;magY;magZ]; % predicted measurement
H_MAG = jacobian(magMeas,stateVector); % measurement Jacobian
[H_MAG,SH_MAG]=OptimiseAlgebra(H_MAG,'SH_MAG');

K_MX = (P*transpose(H_MAG(1,:)))/(H_MAG(1,:)*P*transpose(H_MAG(1,:)) + R_MAG); % Kalman gain vector
[K_MX,SK_MX]=OptimiseAlgebra(K_MX,'SK_MX');
K_MY = (P*transpose(H_MAG(2,:)))/(H_MAG(2,:)*P*transpose(H_MAG(2,:)) + R_MAG); % Kalman gain vector
[K_MY,SK_MY]=OptimiseAlgebra(K_MY,'SK_MY');
K_MZ = (P*transpose(H_MAG(3,:)))/(H_MAG(3,:)*P*transpose(H_MAG(3,:)) + R_MAG); % Kalman gain vector
[K_MZ,SK_MZ]=OptimiseAlgebra(K_MZ,'SK_MZ');

% save equations and reset workspace
save('Magnetometer.mat','SH_MAG','H_MAG','SK_MX','K_MX','SK_MY','K_MY','SK_MZ','K_MZ');
clear all;
reset(symengine);

%% derive equations for sequential fusion of optical flow measurements
load('StatePrediction.mat');

% Range is defined as distance from camera focal point to object measured
% along sensor Z axis
syms range real;

% Define rotation matrix from body to sensor frame
syms Tbs_a_x Tbs_a_y Tbs_a_z real;
syms Tbs_b_x Tbs_b_y Tbs_b_z real;
syms Tbs_c_x Tbs_c_y Tbs_c_z real;
Tbs = [ ...
    Tbs_a_x Tbs_a_y Tbs_a_z ; ...
    Tbs_b_x Tbs_b_y Tbs_b_z ; ...
    Tbs_c_x Tbs_c_y Tbs_c_z ...
    ];

% Calculate earth relative velocity in a non-rotating sensor frame
relVelSensor = Tbs * transpose(Tbn) * [vn;ve;vd];

% Divide by range to get predicted angular LOS rates relative to X and Y
% axes. Note these are rates in a non-rotating sensor frame
losRateSensorX = +relVelSensor(2)/range;
losRateSensorY = -relVelSensor(1)/range;

save('temp1.mat','losRateSensorX','losRateSensorY');

clear all;
reset(symengine);
load('StatePrediction.mat');
load('temp1.mat');

% calculate the observation Jacobian and Kalman gain for the X axis
H_LOSX = jacobian(losRateSensorX,stateVector); % measurement Jacobian
H_LOSX = simplify(H_LOSX);
K_LOSX = (P*transpose(H_LOSX))/(H_LOSX*P*transpose(H_LOSX) + R_LOS); % Kalman gain vector
K_LOSX = simplify(K_LOSX);
save('temp2.mat','H_LOSX','K_LOSX');
ccode([H_LOSX;transpose(K_LOSX)],'file','LOSX.c');
fix_c_code('LOSX.c');

clear all;
reset(symengine);
load('StatePrediction.mat');
load('temp1.mat');

% calculate the observation Jacobian for the Y axis
H_LOSY = jacobian(losRateSensorY,stateVector); % measurement Jacobian
H_LOSY = simplify(H_LOSY);
K_LOSY = (P*transpose(H_LOSY))/(H_LOSY*P*transpose(H_LOSY) + R_LOS); % Kalman gain vector
K_LOSY = simplify(K_LOSY);
save('temp3.mat','H_LOSY','K_LOSY');
ccode([H_LOSY;transpose(K_LOSY)],'file','LOSY.c');
fix_c_code('LOSY.c');

% reset workspace
clear all;
reset(symengine);

%% derive equations for sequential fusion of body frame velocity measurements
load('StatePrediction.mat');

% body frame velocity observations
syms velX velY velZ real;

% velocity observation variance
syms R_VEL real;

% calculate relative velocity in body frame
relVelBody = transpose(Tbn)*[vn;ve;vd];

save('temp1.mat','relVelBody','R_VEL');

% calculate the observation Jacobian for the X axis
H_VELX = jacobian(relVelBody(1),stateVector); % measurement Jacobian
H_VELX = simplify(H_VELX);
save('temp2.mat','H_VELX');
ccode(H_VELX,'file','H_VELX.c');
fix_c_code('H_VELX.c');

clear all;
reset(symengine);
load('StatePrediction.mat');
load('temp1.mat');

% calculate the observation Jacobian for the Y axis
H_VELY = jacobian(relVelBody(2),stateVector); % measurement Jacobian
H_VELY = simplify(H_VELY);
save('temp3.mat','H_VELY');
ccode(H_VELY,'file','H_VELY.c');
fix_c_code('H_VELY.c');

clear all;
reset(symengine);
load('StatePrediction.mat');
load('temp1.mat');

% calculate the observation Jacobian for the Z axis
H_VELZ = jacobian(relVelBody(3),stateVector); % measurement Jacobian
H_VELZ = simplify(H_VELZ);
save('temp4.mat','H_VELZ');
ccode(H_VELZ,'file','H_VELZ.c');
fix_c_code('H_VELZ.c');

clear all;
reset(symengine);

% calculate Kalman gain vector for the X axis
load('StatePrediction.mat');
load('temp1.mat');
load('temp2.mat');

K_VELX = (P*transpose(H_VELX))/(H_VELX*P*transpose(H_VELX) + R_VEL); % Kalman gain vector
K_VELX = simplify(K_VELX);
ccode(K_VELX,'file','K_VELX.c');
fix_c_code('K_VELX.c');

clear all;
reset(symengine);

% calculate Kalman gain vector for the Y axis
load('StatePrediction.mat');
load('temp1.mat');
load('temp3.mat');

K_VELY = (P*transpose(H_VELY))/(H_VELY*P*transpose(H_VELY) + R_VEL); % Kalman gain vector
K_VELY = simplify(K_VELY);
ccode(K_VELY,'file','K_VELY.c');
fix_c_code('K_VELY.c');

clear all;
reset(symengine);

% calculate Kalman gain vector for the Z axis
load('StatePrediction.mat');
load('temp1.mat');
load('temp4.mat');

K_VELZ = (P*transpose(H_VELZ))/(H_VELZ*P*transpose(H_VELZ) + R_VEL); % Kalman gain vector
K_VELZ = simplify(K_VELZ);
ccode(K_VELZ,'file','K_VELZ.c');
fix_c_code('K_VELZ.c');

% reset workspace
clear all;
reset(symengine);

% calculate Kalman gains vectors for X,Y,Z to take advantage of common
% terms
load('StatePrediction.mat');
load('temp1.mat');
load('temp2.mat');
load('temp3.mat');
load('temp4.mat');
K_VELX = (P*transpose(H_VELX))/(H_VELX*P*transpose(H_VELX) + R_VEL); % Kalman gain vector
K_VELY = (P*transpose(H_VELY))/(H_VELY*P*transpose(H_VELY) + R_VEL); % Kalman gain vector
K_VELZ = (P*transpose(H_VELZ))/(H_VELZ*P*transpose(H_VELZ) + R_VEL); % Kalman gain vector
K_VEL = simplify([K_VELX,K_VELY,K_VELZ]);
ccode(K_VEL,'file','K_VEL.c');
fix_c_code('K_VEL.c');


%% derive equations for fusion of 321 sequence yaw measurement
load('StatePrediction.mat');

% Calculate the yaw (first rotation) angle from the 321 rotation sequence
% Provide alternative angle that avoids singularity at +-pi/2
angMeasA = atan(Tbn(2,1)/Tbn(1,1));
angMeasB = pi/2 - atan(Tbn(1,1)/Tbn(2,1));
H_YAW321 = jacobian([angMeasA;angMeasB],stateVector); % measurement Jacobian
H_YAW321 = simplify(H_YAW321);
ccode(H_YAW321,'file','calcH_YAW321.c');
fix_c_code('calcH_YAW321.c');

% reset workspace
clear all;
reset(symengine);

%% derive equations for fusion of 312 sequence yaw measurement
load('StatePrediction.mat');

% Calculate the yaw (first rotation) angle from an Euler 312 sequence
% Provide alternative angle that avoids singularity at +-pi/2
angMeasA = atan(-Tbn(1,2)/Tbn(2,2));
angMeasB = pi/2 - atan(-Tbn(2,2)/Tbn(1,2));
H_YAW312 = jacobian([angMeasA;angMeasB],stateVector); % measurement Jacobian
H_YAW312 = simplify(H_YAW312);
ccode(H_YAW312,'file','calcH_YAW312.c');
fix_c_code('calcH_YAW312.c');

% reset workspace
clear all;
reset(symengine);

%% derive equations for fusion of dual antenna yaw measurement
load('StatePrediction.mat');

syms ant_yaw real; % yaw angle of antenna array axis wrt X body axis

% define antenna vector in body frame
ant_vec_bf = [cos(ant_yaw);sin(ant_yaw);0];

% rotate into earth frame
ant_vec_ef = Tbn * ant_vec_bf;

% Calculate the yaw angle from the projection
angMeas = atan(ant_vec_ef(2)/ant_vec_ef(1));

H_YAWGPS = jacobian(angMeas,stateVector); % measurement Jacobian
H_YAWGPS = simplify(H_YAWGPS);
ccode(H_YAWGPS,'file','calcH_YAWGPS.c');
fix_c_code('calcH_YAWGPS.c');

% reset workspace
clear all;
reset(symengine);

%% derive equations for fusion of declination
load('StatePrediction.mat');

% the predicted measurement is the angle wrt magnetic north of the horizontal
% component of the measured field
angMeas = atan(magE/magN);
H_MAGD = jacobian(angMeas,stateVector); % measurement Jacobian
H_MAGD = simplify(H_MAGD);
K_MAGD = (P*transpose(H_MAGD))/(H_MAGD*P*transpose(H_MAGD) + R_DECL);
K_MAGD = simplify(K_MAGD);
ccode([K_MAGD,H_MAGD'],'file','calcMAGD.c');
fix_c_code('calcMAGD.c');

% reset workspace
clear all;
reset(symengine);

%% derive equations for fusion of lateral body acceleration (multirotors only)
load('StatePrediction.mat');

% use relationship between airspeed along the X and Y body axis and the
% drag to predict the lateral acceleration for a multirotor vehicle type
% where propulsion forces are generated primarily along the Z body axis

vrel = transpose(Tbn)*[(vn-vwn);(ve-vwe);vd]; % predicted wind relative velocity

% calculate drag assuming flight along axis in positive direction
% sign change will be looked after in implementation rather than by adding
% sign functions to symbolic derivation which genererates output with dirac
% functions
% accXpred = -0.5*rho*vrel(1)*vrel(1)*BCXinv; % predicted acceleration measured along X body axis
% accYpred = -0.5*rho*vrel(2)*vrel(2)*BCYinv; % predicted acceleration measured along Y body axis

% Use a simple viscous drag model for the linear estimator equations
% Use the the derivative from speed to acceleration averaged across the
% speed range
% The nonlinear equation will be used to calculate the predicted
% measurement in implementation
accXpred = -Kaccx*vrel(1); % predicted acceleration measured along X body axis
accYpred = -Kaccy*vrel(2); % predicted acceleration measured along Y body axis

% Derive observation Jacobian and Kalman gain matrix for X accel fusion
H_ACCX = jacobian(accXpred,stateVector); % measurement Jacobian
H_ACCX = simplify(H_ACCX);
[H_ACCX,SH_ACCX]=OptimiseAlgebra(H_ACCX,'SH_ACCX'); % optimise processing
K_ACCX = (P*transpose(H_ACCX))/(H_ACCX*P*transpose(H_ACCX) + R_ACC);
[K_ACCX,SK_ACCX]=OptimiseAlgebra(K_ACCX,'SK_ACCX'); % Kalman gain vector

% Derive observation Jacobian and Kalman gain matrix for Y accel fusion
H_ACCY = jacobian(accYpred,stateVector); % measurement Jacobian
H_ACCY = simplify(H_ACCY);
[H_ACCY,SH_ACCY]=OptimiseAlgebra(H_ACCY,'SH_ACCY'); % optimise processing
K_ACCY = (P*transpose(H_ACCY))/(H_ACCY*P*transpose(H_ACCY) + R_ACC);
[K_ACCY,SK_ACCY]=OptimiseAlgebra(K_ACCY,'SK_ACCY'); % Kalman gain vector

% save equations and reset workspace
save('Drag.mat','SH_ACCX','H_ACCX','SK_ACCX','K_ACCX','SH_ACCY','H_ACCY','SK_ACCY','K_ACCY');
clear all;
reset(symengine);

%% Save output and convert to m and c code fragments

% load equations for predictions and updates
load('StateAndCovariancePrediction.mat');
load('Airspeed.mat');
load('Sideslip.mat');
load('Magnetometer.mat');
load('Drag.mat');

fileName = strcat('SymbolicOutput',int2str(nStates),'.mat');
save(fileName);
SaveScriptCode(nStates);
ConvertToM(nStates); % convert symbolic expressions to Matlab expressions
ConvertToC(nStates); % convert Matlab expressions to C code expressions
ConvertCtoC(nStates); % convert covariance matrix expressions from array to matrix syntax

#+END_SRC
* Environment

Consists of:
 - AtmosphereBus
 - Gravity_ned
 - MagneticField

[[file:./images/screenshot-01.png]]
